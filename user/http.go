package user

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"net"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"unsafe"

	"github.com/cilium/ebpf/perf"
	"github.com/szuwgh/villus/common/vlog"
	"golang.org/x/sys/unix"
)

const ETH0 = "ens33"

const (
	SO_DETACH_FILTER = 27
	SO_BINDTODEVICE  = 25
)

type SoEvent struct {
	SrcAddr       uint32
	DstAddr       uint32
	SrcPort       uint16
	DstPort       uint16
	PayloadLength uint32
}

func AttachSocket() error {
	stopper := make(chan os.Signal, 1)
	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)

	defer objs.Close()

	sockFD, err := attachSocketFilter(ETH0, objs.bpfPrograms.SocketHander.FD())
	if err != nil {
		vlog.Fatalf("attach socket filter: %v", err)
	}

	defer syscall.Close(sockFD)
	// ticker := time.NewTicker(2 * time.Second)
	// defer ticker.Stop()
	// rd, err := ringbuf.NewReader(objs.Httpevent)
	// if err != nil {
	// 	vlog.Fatalf("opening ringbuf reader: %s", err)
	// }
	//defer rd.Close()
	go func() {
		<-stopper
		vlog.Println("Received signal, exiting program..")
		if err := detach(sockFD); err != nil {
			vlog.Fatal(err)
		}
		os.Exit(0)
	}()

	vlog.Println("Waiting for events..")

	// bpfEvent is generated by bpf2go.

	rd, err := perf.NewReader(objs.Httpevent, os.Getpagesize())
	if err != nil {
		vlog.Fatalf("creating perf event reader: %s", err)
	}
	defer rd.Close()
	go func() {
		<-stopper
		vlog.Println("Received signal, exiting program..")
		if err := rd.Close(); err != nil {
			vlog.Fatalf("closing perf event reader: %s", err)
		}
	}()
	fmt.Println("Tracing... Hit Ctrl-C to end.")
	fmt.Printf("   %-12s  %-s\n", "EVENT", "TIME(ns)")
	var event SoEvent

	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, perf.ErrClosed) {
				return err
			}
			vlog.Printf("reading from perf event reader: %s", err)
			continue
		}
		if record.LostSamples != 0 {
			vlog.Printf("perf event ring buffer full, dropped %d samples", record.LostSamples)
			continue
		}

		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
			vlog.Printf("parsing perf event: %s", err)
			continue
		}
		vlog.Printf("saddr:%s:%d -> addr: %s:%d \n", intToIP(event.SrcAddr), event.SrcPort, intToIP(event.DstAddr), event.DstPort)
		vlog.Printf("%s\n", record.RawSample[54+16:])

	}
}

func detach(sockFD int) error {
	err := unix.SetsockoptInt(sockFD, unix.SOL_SOCKET, SO_DETACH_FILTER, 0)
	if err != nil {
		return fmt.Errorf("SetSockOpt with SO_DETACH_FILTER failed: %v", err)
	}

	return nil
}

func attachSocketFilter(deviceName string, ebpfProgFD int) (int, error) {
	_, err := net.InterfaceByName(deviceName)
	if err != nil {
		return -1, err
	}

	var sockFD int

	sockFD, err = syscall.Socket(syscall.AF_PACKET, syscall.SOCK_RAW|syscall.SOCK_CLOEXEC, int(htons(syscall.ETH_P_ALL)))
	if err != nil {
		return -1, err
	}

	err = unix.SetsockoptString(sockFD, unix.SOL_SOCKET, SO_BINDTODEVICE, deviceName)
	if err != nil {
		return -1, err
	}

	if err = syscall.SetsockoptInt(sockFD, syscall.SOL_SOCKET, unix.SO_ATTACH_BPF, ebpfProgFD); err != nil {
		return -1, err
	}

	// sll := syscall.SockaddrLinklayer{
	// 	Ifindex:  netInterface.Index,
	// 	Protocol: htons(syscall.ETH_P_ALL),
	// }
	// if err = syscall.Bind(sockFD, &sll); err != nil {
	// 	return -1, err
	// }
	return sockFD, nil
}

// processSocket processes 100 packets from socket.
// Check for each packet if it contains http method.
// If true, print the status line.
func processSocket(sockFD int) {
	fmt.Println("start printing payload for packets with port 80:")

	buf := make([]byte, 65536)
	const macHdrLen = 14

	for i := 0; i < 100; i++ {
		n, _, err := syscall.Recvfrom(sockFD, buf, 0)
		if err != nil {
			continue
		}

		layer2 := buf[macHdrLen:n]
		// minimum ip header length is 20B
		if len(layer2) < 20 {
			continue
		}

		srcIPBytes := layer2[12:16]
		dstIPBytes := layer2[16:20]

		ipTotalLen := int(layer2[2])<<8 + int(layer2[3])
		ipHdrLen := int(layer2[0]&0xf) << 2
		layer3 := layer2[ipHdrLen:]

		// minimum tcp header length is 20B
		if len(layer3) < 20 {
			continue
		}

		srcPortBytes := layer3[0:2]
		DstPortBytes := layer3[2:4]
		tcpHdrLen := int(layer3[12]&0xf0) >> 2

		payloadLen := ipTotalLen - (tcpHdrLen + ipHdrLen)
		if payloadLen <= 0 {
			continue
		}

		payload := string(layer3[tcpHdrLen:])

		if !httpMethod(payload) {
			continue
		}

		index := strings.Index(payload, "\r\n")
		if index != -1 {
			payload = payload[:index]
		}

		fmt.Printf("    %s:%d -> %s:%d    %s\n",
			ipString(srcIPBytes), portInt(srcPortBytes), ipString(dstIPBytes), portInt(DstPortBytes), payload)
	}

	fmt.Println("packet capture stopped")
}

// htons converts the unsigned short integer hostshort from host byte order to network byte order.
func htons(i uint16) uint16 {
	b := make([]byte, 2)
	binary.BigEndian.PutUint16(b, i)
	return *(*uint16)(unsafe.Pointer(&b[0]))
}

func ipString(ip []byte) string {
	return fmt.Sprintf("%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3])
}

func portInt(port []byte) int {
	return int(port[0])<<8 + int(port[1])
}

func httpMethod(payload string) bool {
	// http requires 8B minimum length
	if len(payload) < 8 {
		return false
	}
	if payload[:3] == "GET" {
		return true
	}
	if payload[:4] == "POST" {
		return true
	}
	if payload[:4] == "HTTP" {
		return true
	}

	// More methods like "PUT" can be added here
	return false
}
